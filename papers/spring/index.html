<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-2">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 2.0  (Linux)">
	<META NAME="AUTHOR" CONTENT="Luk&aacute;&scaron; Zapletal">
	<META NAME="CREATED" CONTENT="20051025;22540300">
	<META NAME="CHANGEDBY" CONTENT="Luk&aacute;&scaron; Zapletal">
	<META NAME="CHANGED" CONTENT="20051128;17484000">
</HEAD>
<BODY LANG="cs-CZ" LINK="#000080" VLINK="#800000" DIR="LTR">
<H1 ALIGN=CENTER>Spring Framework<BR><FONT SIZE=4>tvorba obchodn&iacute;ch
aplikac&iacute; v Javì bez J2EE</FONT></H1>
<DL>
	<DT>Firma Sun Microsystems dod&aacute;v&aacute; ji¾ nìkolik let
	programovou platformu J2EE (Java 2 Enterprise Edition). Jedn&aacute;
	se o standardizovanou distribuovanou komponentovou technologii
	doplnìnou o mnoho knihoven a API, kter&eacute; jsou potøebn&eacute;
	pøi tvorbì enterprise aplikac&iacute;. Jedn&aacute; se zejm&eacute;na
	o technologie Servlet, JSP/JSF, JNDI, JTA, JMS a webov&eacute;
	slu¾by. J&aacute;dro tvoø&iacute; komponentov&aacute; technologie,
	kterou si pøedstav&iacute;me.</DL>
<H2>
Enterprise JavaBeans</H2>
<DL>
	<DT>Nejprve je nutno osvìtlit, co je to vlastnì enterprise aplikace
	&ndash; jedn&aacute; se o softwarovou aplikaci, kterou firma
	vyvinula, zakoupila nebo pøevzala, poskytuj&iacute;c&iacute;
	strategick&eacute; slu¾by dan&eacute; firmì. Mù¾e se jednat o
	podnikov&eacute; libovoln&eacute; procesy (&uacute;èetnictv&iacute;,
	sklad), ERP (Enterprise Resource Planning &ndash; pl&aacute;nov&aacute;n&iacute;
	a spr&aacute;va v&yacute;robn&iacute;ho procesu), CRM (Customer
	Relatationship Management &ndash; spr&aacute;va vztahu se
	z&aacute;kazn&iacute;ky). Tento pojem nevymyslela firma Sun, ale je
	zde ji¾ øadu let. Dø&iacute;ve byly tyto aplikace &uacute;zce
	sv&aacute;z&aacute;ny s mainframy a napø&iacute;klad jazykem
	Fortran.<DT>
	EJB jsou komponenty, kter&eacute; se nasazuj&iacute; na aplikaèn&iacute;m
	serveru (tzv EJB kontejneru) poskytuj&iacute;c&iacute;m bezpeèn&eacute;
	a spolehliv&eacute; prostøed&iacute; nutn&yacute; pro jejich bìh.
	Tyto komponenty jsou dostupn&eacute; a instalovateln&eacute; pøes
	s&iacute;» a jejich &uacute;lohou je poskytovat n&aacute;stroj pro
	tvorbu enterprise aplikac&iacute;. Jen pøipomenu, ¾e softwarov&aacute;
	komponenta m&aacute;, na rozd&iacute;l od obyèejn&eacute; tø&iacute;dy
	(napø. v jazyce Java), jasnì dan&eacute; rozhran&iacute;, explicitnì
	dan&eacute; z&aacute;vislosti na jin&yacute;ch komponent&aacute;ch a
	mus&iacute; b&yacute;t mo¾n&eacute; ji nasadit nez&aacute;visle jako
	produkt tøet&iacute; strany.<DT>
	Komponenty je mo¾n&eacute; pøedstavit si jako èern&eacute; skø&iacute;òky,
	kter&eacute; lze v syst&eacute;mu (aplikaèn&iacute;m serveru)
	vymìnit za jin&eacute; implementace (kter&eacute; si mù¾eme tøeba
	zakoupit od jin&eacute;ho dodavatele). Mù¾e se jednat o primitivn&iacute;
	komponentu, kter&aacute; um&iacute; odeslat e-mail, nebo o slo¾itou
	komponentu schopnou pøedpov&iacute;dat poèas&iacute; &ndash; ta by
	se mohla skl&aacute;dat z nìkolika (stovek) jin&yacute;ch komponent.
	EJB  komponenty tohle v&scaron;echno splòuj&iacute; a pøid&aacute;vaj&iacute;
	nìkter&eacute; vìci nav&iacute;c, jako jsou popisy nasazen&iacute;,
	napojen&iacute; na st&aacute;vaj&iacute;c&iacute; komponentov&eacute;
	technologie (CORBA) a hlavnì my&scaron;lenku jazyka Javy - &bdquo;napi&scaron;
	to jednou a provozuj kdekoli&ldquo;. Nutno ø&iacute;ci, ¾e toto
	Sunem prosazovan&eacute; heslo (&bdquo;Write once, run everywhere&ldquo;)
	zaèala skuteènì naplòovat a¾ technologie J2EE a pr&aacute;vì EJB.<DT>
	Jak pozdìji uvid&iacute;me, enterprise aplikace se obvykle tvoø&iacute;
	jako v&iacute;cevrstv&eacute;. Pr&aacute;vì vrstva aplikaèn&iacute;
	logiky (business logic) je tvoøena (obvykle v&iacute;ce) EJB
	komponentami. Tyto komponenty mezi sebou pomoc&iacute; rozhran&iacute;
	komunikuj&iacute; a je vhodn&eacute; rozli&scaron;ovat v&iacute;ce
	typù  komponent. Business objekt se obvykle svazuje s øe&scaron;enou
	dom&eacute;nou a jedn&aacute; se o nìjak&yacute;m zpùsobem
	perzistentn&iacute; element (ulo¾en&yacute; napø&iacute;klad v
	datab&aacute;zi). Urèitì by nebylo vhodn&eacute; do business objektu
	ps&aacute;t aplikaèn&iacute; logiku (i kdy¾ by objektovì orientovan&eacute;
	programov&aacute;n&iacute; mohlo sv&aacute;dìt k tomu prostì
	vytvoøit metodu nad objektem). Abyste mohli business objekty znovu
	pou¾&iacute;vat i v jin&yacute;ch aplikac&iacute;ch, je dobr&eacute;
	aplikaèn&iacute; logiku zapouzdøit v jin&yacute;ch komponent&aacute;ch.
	Tìmito komponentami jsou takzvan&eacute; aplikaèn&iacute; kontrolery
	(vykon&aacute;vaj&iacute; nìjakou akci). Pokud se budeme bavit v
	term&iacute;nech EJB, pr&aacute;vì jsem zm&iacute;nil entity beans a
	session beans. V aktu&aacute;ln&iacute; verzi J2EE 1.4 je&scaron;tì
	existuj&iacute; message driven beans, kter&eacute; n&aacute;s v tuto
	chv&iacute;li nezaj&iacute;maj&iacute;.<DT>
	J2EE rozli&scaron;uje dva typy entity beans a dva typy session
	beans. V prvn&iacute;m pø&iacute;padì dìl&iacute;me business objekty
	na CMP (kontejner se star&aacute; o perzistenci s&aacute;m) a BMP
	(program&aacute;tor komponenty se star&aacute; o ukl&aacute;d&aacute;n&iacute;).
	Komponenty sessions beans s aplikaèn&iacute; logikou dìl&iacute;
	J2EE na stavov&eacute; (stateful &ndash; pamatuj&iacute; si klienty)
	a bezstavov&eacute; (stateless &ndash; nepamatuj&iacute; si sv&eacute;
	klienty). Kontejnery J2EE jsou nav&iacute;c schopny transakèn&iacute;ho
	zpracov&aacute;n&iacute; operac&iacute; session beanu. Pø&iacute;kladem
	prvn&iacute;ho typu je n&aacute;kupn&iacute; ko&scaron;&iacute;k,
	druh&eacute;ho typu pak komponenta pro zas&iacute;l&aacute;n&iacute;
	SMS zpr&aacute;v (klienta nezaj&iacute;m&aacute;, kterou z instanc&iacute;
	kontejner vybere, pokud jich m&aacute; dostupn&yacute;ch v&iacute;c).<DT>
	T&iacute;m bych ukonèil z&aacute;kladn&iacute; pøehled technologie
	Enterprise Java Beans, kter&aacute; tvoø&iacute; j&aacute;dro J2EE.
	K dal&scaron;&iacute;m t&eacute;matùm se dostaneme pøi rozboru
	Springu.</DL>
<H2>
Motivace pro Spring Framework</H2>
<DL>
	<DT>Pùvodn&iacute; my&scaron;lenka padla v knize Roda Johnsona
	Expert One-on-One J2EE Design and Development, kter&aacute; bohu¾el
	nevy&scaron;la v èe&scaron;tinì ani sloven&scaron;tinì. Rod v n&iacute;
	prob&iacute;r&aacute; sice z&aacute;klady J2EE, ale poukazuje na
	mo¾n&eacute; probl&eacute;my v technologii jako samotn&eacute;, ale
	zejm&eacute;na ve &scaron;patn&eacute;m aplikov&aacute;n&iacute;
	tìchto postupù.<DT>
	Jako z&aacute;kladn&iacute; probl&eacute;m se jev&iacute; pou¾it&iacute;
	J2EE za situac&iacute;ch, kdy to vùbec nen&iacute; vhodn&eacute;.
	Takov&eacute; situace lze zjistit snadno &ndash; v pø&iacute;padì,
	¾e nepou¾it&iacute; t&eacute;to technologie v&yacute;raznì sn&iacute;¾&iacute;
	slo¾itost probl&eacute;mu, a tedy i d&eacute;lku projektu. Nemus&iacute;
	se jednat nutnì o komplexnost samotn&eacute;ho programov&aacute;n&iacute;,
	zt&iacute;¾eno mù¾e b&yacute;t i nasazen&iacute; a pøenositelnost
	(nìkter&eacute; aplikaèn&iacute; servery roz&scaron;iøuj&iacute;
	specifikaci, probl&eacute;my s datab&aacute;zovou pøenositelnost&iacute;).
	V n&aacute;sleduj&iacute;c&iacute;ch odstavc&iacute;ch pøedstav&iacute;m
	hlavn&iacute; faktory pro vznik tohoto projektu.<DT>
	Asi nejvìt&scaron;&iacute;m probl&eacute;mem je <B>pø&iacute;li&scaron;n&aacute;
	komplikovanost</B> J2EE, aèkoliv to nebylo hlavn&iacute;m motorem
	pøi v&yacute;voji Springu. Technologie jako takov&aacute; obsahuje
	velk&eacute; mno¾stv&iacute; rozhran&iacute;, kter&eacute; jsou d&aacute;le
	roz&scaron;iøov&aacute;ny dodavateli aplikaèn&iacute;ch serverù.
	Mnoho softwarov&yacute;ch spoleènost&iacute; nedodr¾uje standardy a
	vznikaj&iacute; tak probl&eacute;my pøi pøenositelnosti. Technologie
	J2EE tak&eacute; trpìla nìkter&yacute;mi nedostatky v n&aacute;vrhu,
	kter&eacute; sice byly eliminov&aacute;ny v dal&scaron;&iacute;ch
	verz&iacute;ch, ale musela b&yacute;t zachov&aacute;na zpìtn&aacute;
	kompatibilita. V&yacute;voj J2EE tak&eacute; nebyl nikterak rychl&yacute;
	a zmìny, kter&eacute; firmy po¾adovaly, se projevovaly pø&iacute;li&scaron;
	pomalu.<DT>
	Spring umo¾òuje <B>snadn&eacute; vìci dìlat jednodu&scaron;e</B>,
	av&scaron;ak pøi zachov&aacute;n&iacute; vysok&eacute;
	&scaron;k&aacute;lovatelnosti a roz&scaron;iøitelnosti. D&aacute;le
	cel&eacute; rozhran&iacute; klade velk&yacute; <B>dùraz na dobr&eacute;
	praktiky</B> v programov&aacute;n&iacute; (<SPAN LANG="en-US">best</SPAN>
	<SPAN LANG="en-US">practices</SPAN>) &ndash; napø&iacute;klad
	mo¾nosti v testov&aacute;n&iacute;. Spring je st&aacute;le ve v&yacute;voji
	a rychle reaguje na nov&eacute; techniky ve v&yacute;voji obchodn&iacute;ch
	aplikac&iacute;, kter&eacute; tøeba jinde je&scaron;tì nejsou
	aplikov&aacute;ny.<DT>
	Mo¾nosti <B>jednoduch&yacute;ch z&aacute;sahù do samotn&eacute;ho
	frameworku</B> jsou dal&scaron;&iacute;m krit&eacute;riem, kter&eacute;
	by mohlo rozhodovat pøi volbì mezi J2EE a Springem. Spring je
	nesm&iacute;rnì modul&aacute;rn&iacute;, jedn&aacute; se o sadu
	rozhran&iacute; s mnoha rùzn&yacute;mi implementacemi. V neposledn&iacute;
	øadì je mo¾n&eacute; zasahovat pø&iacute;mo do zdrojov&eacute;ho
	k&oacute;du (Spring jako takov&yacute; je open-source softwarem),
	vèetnì mo¾nosti vytvoøit si vlastn&iacute; aplikaèn&iacute; r&aacute;mec
	nad Springem a d&aacute;le jej distribuovat, nebo se pø&iacute;mo
	&uacute;èastnit v&yacute;voje a participovat se na dal&scaron;&iacute;ch
	verz&iacute;ch.<DT>
	Spring <B>nevy¾aduje ¾&aacute;dn&eacute; z&aacute;vislosti</B>.
	Aèkoli m&aacute; distribuce Springu kolem 100 MB, vlastn&iacute;
	j&aacute;dro nen&iacute; z&aacute;visl&eacute; na ¾&aacute;dn&eacute;
	knihovnì a a¾ s postupem projektu v&yacute;vojov&yacute; t&yacute;m
	pøid&aacute;v&aacute; nov&eacute; z&aacute;vislosti. Nen&iacute;
	potøeba ¾&aacute;dn&eacute;ho aplikaèn&iacute;ho serveru, av&scaron;ak
	ta mo¾nost tady je.<DT>
	D&iacute;ky vp&iacute;chnut&iacute; z&aacute;vislost&iacute; (viz
	d&aacute;le) <B>aplikace nejsou pø&iacute;mo z&aacute;visl&eacute;</B>
	na Springu a nic program&aacute;torovi tak nebr&aacute;n&iacute;
	aplikaci zprovoznit nad jin&yacute;mi aplikaèn&iacute;mi rozhran&iacute;mi.
	V neposledn&iacute; øadì nab&iacute;z&iacute; Spring <B>jednotnou
	konfiguraci</B>, kter&aacute; je tak&eacute; snadno pochopiteln&aacute;.</DL>
<H2>
Vp&iacute;chnut&iacute; z&aacute;vislost&iacute;</H2>
<DL>
	<DT>Spring samotn&yacute; je postaven na my&scaron;lence Martina
	Flowera, &scaron;pièkov&eacute;ho experta na poli objektovì
	orientovan&yacute;ch pø&iacute;stupù, kterou pùvodnì nazval
	<I>Inversion Of Control</I> pøevr&aacute;cen&iacute; z&aacute;vislost&iacute;),
	ale vz&aacute;pìt&iacute; tento n&aacute;vrhov&yacute; vzor
	pøejmenoval na <I>Dependency Injection</I> (vp&iacute;chnut&iacute;
	z&aacute;vislost&iacute;). Poprv&eacute; tento n&aacute;vrhov&yacute;
	vzor publikoval na internetu [2]. Jeliko¾ pochopen&iacute; pojmu
	vp&iacute;chnut&iacute; z&aacute;vislost&iacute; je pro dal&scaron;&iacute;
	v&yacute;klad nezbytn&eacute;, r&aacute;d bych jej zde uvedl. Na
	okraj bych je&scaron;tì uvedl, ¾e jsem se rozhodl tento n&aacute;vrhov&yacute;
	vzor pojmenovat jako &bdquo;vp&iacute;chnut&iacute;&ldquo;, proto¾e
	se s èesk&yacute;m v&yacute;razem daleko l&eacute;pe pracuje.<DT>
	Pøi n&aacute;vrhu jak&eacute;koliv komponentov&eacute; technologie
	naraz&iacute;te hned na zaè&aacute;tku na jeden kl&iacute;èov&yacute;
	probl&eacute;m. Je nutn&eacute; vytv&aacute;øen&eacute; komponenty
	nìjak efektivnì propojit do funkèn&iacute;ch celkù. U¾ z definice
	samotn&eacute; komponenty vypl&yacute;v&aacute;, ¾e se mus&iacute;
	jednat o samostatn&eacute; a snadno vymìniteln&eacute; jednotky. V
	dne&scaron;n&iacute; dobì, kdy poè&iacute;taèov&eacute; s&iacute;tì
	maj&iacute; hlavn&iacute; roli t&eacute;mìø ve v&scaron;ech
	odvìtv&iacute;ch IT prùmyslu, je tak&eacute; vhodn&eacute;, aby byly
	komponenty dostupn&eacute; tak&eacute; pøes s&iacute;» (popø.
	internet).<DT>
	Je tedy nutn&eacute; vymyslet zpùsob, jak komponenty mezi sebou
	skl&aacute;dat do aplikac&iacute;. Vìt&scaron;ina komponentov&yacute;ch
	technologi&iacute; vyu¾&iacute;v&aacute; vyhled&aacute;vac&iacute;ch
	slu¾eb (Service Locator, viz [3]) &ndash; ka¾d&aacute; komponenta se
	zaregistruje do urèit&eacute;ho kontextu a pokud nìjak&aacute;
	komponenta chce pou¾&iacute;t jinou, mus&iacute; si ji explicitnì
	pøes pøedem dohodnutou vyhled&aacute;vac&iacute; slu¾bu naj&iacute;t.
	V&scaron;echny komponenty musej&iacute; obvykle implementovat
	rùznorod&aacute; rozhran&iacute;, aby je bylo mo¾n&eacute; v
	kontextu vyhledat a pou¾&iacute;t. Na n&aacute;sleduj&iacute;c&iacute;m
	obr&aacute;zku je vidìt, ¾e komponenta MovieLister vytvoø&iacute;
	instanci komponenty implementuj&iacute;c&iacute; rozhran&iacute;
	MovieFinder (napø&iacute;klad zmiòovan&yacute;m zpùsobem, nebo
	jakkoli jinak).<DT>
	<IMG SRC="spring_html_m457764dd.gif" NAME="obr&aacute;zky2" ALIGN=LEFT WIDTH=302 HEIGHT=176 BORDER=0><BR CLEAR=LEFT><BR>
	<DT>Vp&iacute;chnut&iacute; z&aacute;vislost&iacute; v&scaron;e
	obrac&iacute; naruby, existuje jak&yacute;si sestavovatel, kter&yacute;
	komponenty podle urèit&yacute;ch pravidel inicializuje a nìjak&yacute;m
	zpùsobem jim pøed&aacute; odkazy na ostatn&iacute; komponenty.
	Pø&iacute;klad je vidìt na obr&aacute;zku.<DT>
	<IMG SRC="spring_html_5de23164.gif" NAME="obr&aacute;zky1" ALIGN=LEFT WIDTH=446 HEIGHT=211 BORDER=0><BR CLEAR=LEFT>Zde
	vid&iacute;me komponenty MovieLister (co¾ je patrnì komponenta
	generuj&iacute;c&iacute; seznam filmù na z&aacute;kladì nìjak&eacute;ho
	dotazu), MovieFinder (komponenta urèen&aacute; pro vyhled&aacute;v&aacute;n&iacute;
	v datab&aacute;zi vèetnì implementace) a Assembler (prvek
	zaji&scaron;»uj&iacute;c&iacute; spr&aacute;vn&eacute; propojen&iacute;
	komponent). Assembler tedy z&aacute;vislosti do objektù vlo¾&iacute;,
	doslova vstø&iacute;kne (to inject &ndash; vp&iacute;chnout jehlou).<DT>
	<I><B>Pozn&aacute;mka</B>: Nejedn&aacute; se tedy o ¾&aacute;dnou
	z&aacute;sadn&iacute; zmìnu oproti Service Locatoru, jen je to jin&yacute;
	pohled na vìc. Jako u v&scaron;eho ostatn&iacute;ho v programov&aacute;n&iacute;
	se ned&aacute; ø&iacute;ci, ¾e je tento pø&iacute;stup lep&scaron;&iacute;
	nebo hor&scaron;&iacute; &ndash; to je relativn&iacute;. Stejnì tak
	nelze ø&iacute;ci, jestli je lep&scaron;&iacute; Spring nebo J2EE &ndash;
	k rùzn&yacute;m &uacute;èelùm jsou vhodn&aacute; rùzn&aacute;
	øe&scaron;en&iacute;. </I>
	<DT>Rozli&scaron;ujeme tøi typy realizace vstø&iacute;knut&iacute;:</DL>
<UL>
	<LI>
	interface injection (pomoc&iacute; rozhran&iacute;)<LI>
	setter injection (pomoc&iacute; vlastnosti objektu)<LI>
	constructor injection (pomoc&iacute; konstruktoru)</UL>
<DL>
	<DT>Popis zaènu tro&scaron;ku netradiènì &ndash; dvìma posledn&iacute;mi.
	Vlastn&iacute; pøed&aacute;n&iacute; odkazù na komponenty se prov&aacute;n&iacute;
	pø&iacute;mo v konstruktoru komponenty, respektive pøes set metody
	(pøes vlastnosti objektù). Martin Flower v&scaron;e ukazuje na
	jednoduch&eacute; knihovnì PicoContainer, kterou vytvoøili jeho
	kolegov&eacute; z firmy, ve kter&eacute; Martin pùsob&iacute;. Jedn&aacute;
	se o malou java knihovnu, kter&aacute; nab&iacute;z&iacute; v&scaron;echny
	popisovan&eacute; typy vstø&iacute;knut&iacute; z&aacute;vislost&iacute;,
	pø&iacute;klady a dokumentaci. Je dostupn&aacute; jako open-source
	software na adrese <I>http://www.picocontainer.org/</I>, kde jsou
	odkazy i na implementace v jin&yacute;ch jazyc&iacute;ch.<DT>
	Pøedstavme si, ¾e m&aacute;me tø&iacute;du</DL>
<PRE LANG=""><FONT SIZE=2><B>class MovieLister {</B></FONT>
<FONT SIZE=2><SPAN LANG=""><B>	...</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>	public MovieLister(MovieFinder finder) {</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>		this.finder = finder;       </B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>	}</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>}</B></SPAN></FONT></PRE>
<DL>
	<DT>
	Tato tø&iacute;da oèek&aacute;v&aacute; ve sv&eacute;m konstruktoru
	komponentu MovieFinder, jej&iacute;¾ implementace by mohla vypadat
	n&aacute;sledovnì</DL>
<PRE LANG=""><FONT SIZE=2><B>class SQLMovieFinder implements MovieFinder {</B></FONT>
<FONT SIZE=2><SPAN LANG=""><B>	...</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>	public SQLMovieFinder(String dbServer) {</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>		this.server = dbServer;</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>	}</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>}</B></SPAN></FONT></PRE>
<DL>
	<DT>
	Parametrem je jak&eacute;si spojen&iacute; do datab&aacute;ze, kde
	jsou ulo¾eny informace o filmech. Nyn&iacute; staè&iacute;
	assembleru vytvoøit instance tìchto tø&iacute;d a v konstruktoru
	tø&iacute;dy MovieLister uv&eacute;st odkaz na SQLMovieFinder.
	Nebudu se zde pou&scaron;tìt do popisu, jak to dìl&aacute;
	PicoContainer, na kter&eacute;m v&scaron;e vysvìtluje Martin Flower
	ve sv&eacute; pr&aacute;ci, proto¾e to nen&iacute; c&iacute;lem m&eacute;ho
	textu. Zùstaneme jen u toho, ¾e je nutn&eacute; toto dìlat za bìhu,
	tak¾e PicoContainer je schopn&yacute; pracovat se tø&iacute;dami,
	kter&eacute; vùbec &bdquo;nezn&aacute;&ldquo;.<DT>
	Jistì si dok&aacute;¾ete pøedstavit, jak by vypadalo vp&iacute;chnut&iacute;
	pomoc&iacute; set metody. Konstruktor by v tomto pø&iacute;padì
	nemìl  ¾&aacute;dn&eacute; parametry a odkazy na komponenty by se
	pøed&aacute;valy a¾ po vytvoøen&iacute; objektu pomoc&iacute;
	vlastnost&iacute;. Hlavn&iacute;m pø&iacute;nosem je zde mo¾nost
	vytv&aacute;øet instance komponent pomoc&iacute; skriptovac&iacute;ch
	nebo znaèkovac&iacute;ch jazykù, napø&iacute;klad XML. Mohlo by to
	vypadat napø&iacute;klad n&aacute;sledovnì:</DL>
<PRE LANG="">     <FONT SIZE=2><B>&lt;component id=&quot;MovieLister&quot; class=&quot;package.MovieLister&quot;&gt;</B></FONT>
         <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;finder&quot;&gt;</B></SPAN></FONT>
             <FONT SIZE=2><SPAN LANG=""><B>&lt;ref local=&quot;MovieFinder&quot;/&gt;</B></SPAN></FONT>
         <FONT SIZE=2><SPAN LANG=""><B>&lt;/property&gt;</B></SPAN></FONT>
     <FONT SIZE=2><SPAN LANG=""><B>&lt;/component&gt;</B></SPAN></FONT>
     <FONT SIZE=2><SPAN LANG=""><B>&lt;component id=&quot;MovieFinder&quot; class=&quot;package.ColonMovieFinder&quot;&gt;</B></SPAN></FONT>
         <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;server&quot;&gt;</B></SPAN></FONT>
             <FONT SIZE=2><SPAN LANG=""><B>&lt;value&gt;phoenix:4398&lt;/value&gt;</B></SPAN></FONT>
         <FONT SIZE=2><SPAN LANG=""><B>&lt;/property&gt;</B></SPAN></FONT>
     <FONT SIZE=2><SPAN LANG=""><B>&lt;/component&gt;</B></SPAN></FONT></PRE>
<DL>
	<DT>
	Tøet&iacute; metodou je vp&iacute;chnut&iacute; pomoc&iacute;
	rozhran&iacute;, kdy se pro vlo¾en&iacute; z&aacute;vislosti vytvoø&iacute;
	speci&aacute;ln&iacute; rozhran&iacute;, co¾ by v tomto na&scaron;em
	pø&iacute;kladì mohla b&yacute;t napø&iacute;klad metoda
	<B>injectFinder(MovieFinder)</B>. Tento zpùsob umo¾òuje o nìco vìt&scaron;&iacute;
	abstrakci, co¾ je vykoupeno ponìkud vy&scaron;&scaron;&iacute;
	re¾i&iacute;.<DT>
	Existuj&iacute; dva hlavn&iacute; (open-source) projekty zalo¾en&eacute;
	na vp&iacute;chnut&iacute; z&aacute;vislost&iacute; a to je Apache
	Avalon a NanoContainer. Prvn&iacute; ze jmenovan&yacute;ch se stal
	z&aacute;kladem pro nìkolik produktù nadace Apache Free Foundation a
	vyu¾&iacute;v&aacute; vp&iacute;chnut&iacute; pomoc&iacute;
	rozhran&iacute;. NanoContainer roz&scaron;iøuje mo¾nosti
	PicoContaineru o skriptov&aacute;n&iacute; (z&aacute;vislosti lze
	definovat pomoc&iacute; libovoln&eacute;ho jazyka, vèetnì XML),
	nasazen&iacute; (deployment, composition skripty), vzd&aacute;len&eacute;
	vol&aacute;n&iacute; (remoting), perzistenci objektù, AOP a webov&eacute;
	slu¾by. Na rozd&iacute;l od Avalonu je NanoContainer je ale st&aacute;le
	malou knihovnou a nevy¾aduje t&eacute;mìø ¾&aacute;dn&eacute;
	z&aacute;vislosti.</DL>
<H2>
Pøedstaven&iacute; Spring Frameworku</H2>
<DL>
	<DT>Hlavn&iacute; my&scaron;lenka t&eacute;to knihovny (jedn&aacute;
	se vlastnì o sadu knihoven &ndash; spolu s dokumentac&iacute; se
	jedn&aacute; o v&iacute;ce jak 100 MB dat) je ve vytvoøen&iacute;
	jednoduch&eacute;, ale &uacute;èinn&eacute; komponentov&eacute;
	technologie zalo¾en&eacute; na modern&iacute;ch postupech, a podobnì
	jako u J2EE na jazyku XML. Spring se sna¾&iacute; pokr&yacute;t
	ve&scaron;ker&eacute; oblasti spojen&eacute; s v&yacute;vojem
	obchodn&iacute;ch aplikac&iacute; s dùrazem na datab&aacute;ze, web
	a aspektovì orientovan&eacute;ho programov&aacute;n&iacute;.<DT>
	Spring je tedy jak&eacute;si lepidlo mezi mnoha open-source
	knihovnami a sna¾&iacute; se co nejlep&scaron;&iacute;m zpùsobem
	zobecnit z&aacute;kladn&iacute; API slou¾&iacute;c&iacute; pro
	programov&aacute;n&iacute; obchodn&iacute;ch aplikac&iacute;.
	Z&aacute;kladem je komponentov&aacute; technologie, d&aacute;le pak
	kontext aplikace (podpora konfigurace, prostøedkù, UI, validace,
	adres&aacute;øov&yacute;ch slu¾eb èi zas&iacute;l&aacute;n&iacute;
	po&scaron;ty), datab&aacute;zov&aacute; vrstva (DAO, transakce), O/R
	mapov&aacute;n&iacute; a webov&eacute; programov&aacute;n&iacute;
	(modely, pohledy, zpùsob propojen&iacute; modelù). K tomu v&scaron;emu
	je&scaron;tì Spring pøid&aacute;v&aacute; AOP.<DT>
	<BR>
	<DT><IMG SRC="spring_html_6e830381.gif" NAME="obr&aacute;zky3" ALIGN=LEFT WIDTH=642 HEIGHT=340 BORDER=0><BR CLEAR=LEFT><BR>
	<DT>Jak vid&iacute;me na obr&aacute;zkù, kl&iacute;èovou vrstvou je
	j&aacute;dro nazvan&eacute; <B>Spring Core</B>, kter&eacute;
	pøedstavuje vlastn&iacute; komponentovou technologii (paralela s
	EJB), d&aacute;le kontejner pro tyto komponenty a potøebn&eacute;
	n&aacute;stroje. K tomuto &uacute;èelu se vyu¾&iacute;v&aacute;
	popsan&aacute; technologie vp&iacute;chnut&iacute; z&aacute;vislost&iacute;.
	Nad t&iacute;mto j&aacute;drem se nach&aacute;zej&iacute; bal&iacute;ky
	(dokumentace je doslova takto naz&yacute;v&aacute;, proto¾e vlastn&iacute;
	implementace v Javì je rozdìlena do pr&aacute;vì tìchto bal&iacute;èkù),
	kter&eacute; bych detailnìji popsal.<DT>
	Asi nejdùle¾itìj&scaron;&iacute;m je <B>Spring Context</B>, kter&yacute;
	obsahuje aplikaèn&iacute; kontext a podpùrn&eacute; komponenty pro
	tvorbu u¾ivatelsk&eacute;ho rozhran&iacute;, pro validaci vstupù,
	pos&iacute;l&aacute;n&iacute; zpr&aacute;v a e-mailù a v neposledn&iacute;
	øadì se zde realizuje velmi dùle¾it&eacute; napojen&iacute; na EJB.
	Spring je toti¾ kompatibiln&iacute; s EJB a mù¾ete v nìm tyto
	komponenty jak vytv&aacute;øet, tak pou¾&iacute;vat.<DT>
	<B>Spring DAO</B> zastøe&scaron;uje v&scaron;echny kl&iacute;èov&eacute;
	datab&aacute;zov&eacute; technologie a aèkoliv by se mohla dal&scaron;&iacute;
	DB vrstva zd&aacute;t zbyteèn&aacute;, velmi brzy pozn&aacute;te, ¾e
	i JDBC je nutno nìjak&yacute;m zpùsobem sjednotit (napø&iacute;klad
	velmi nejednotn&eacute; jsou v&yacute;jimky a chybov&eacute; zpr&aacute;vy
	jednotliv&yacute;ch datab&aacute;zov&yacute;ch dodavatelù). Nemluvì
	o to, ¾e tento bal&iacute;k pøid&aacute;v&aacute; jednotnou podporu
	pro transakce a mnoho dal&scaron;&iacute;ch n&aacute;strojù
	zjednodu&scaron;uj&iacute;c&iacute;ch pr&aacute;ci s datab&aacute;z&iacute;.<DT>
	Nad t&iacute;mto bal&iacute;kem stoj&iacute; <B>ORM</B> &ndash; tedy
	objektovì relaèn&iacute; mapov&aacute;n&iacute;. Spring nepou¾&iacute;v&aacute;
	¾&aacute;dnou obdobu entity java beans, jako je tomu u EJB. Je to
	v&yacute;hodn&eacute;, proto¾e mnoho softwarov&yacute;ch spoleènost&iacute;
	vùbec entity EJB komponenty nepou¾&iacute;valo a psalo si vlastn&iacute;
	DB vrstvy. Spring tedy vkl&aacute;d&aacute; abstraktn&iacute; vrstvu
	mezi j&aacute;dro (resp. DAO) a dodavatele ORM technologi&iacute;.
	Se Springem se distribuuje nìkolik adapt&eacute;rù na rùzn&eacute;
	open-source ORM knihovny vèetnì nejpou¾&iacute;vanìj&scaron;&iacute;
	&ndash; projektu Hibernate.<DT>
	Bal&iacute;k pro <B>AOP</B> nab&iacute;z&iacute; napojen&iacute; na
	aspektovì orientovan&eacute; programov&aacute;n&iacute; v Javì.
	Tomuto t&eacute;matu se ve sv&yacute;ch pøedn&aacute;&scaron;k&aacute;ch
	budou vìnovat moji kolegov&eacute;, nicm&eacute;nì jen bych dodal,
	¾e AOP jde ruku v ruce pr&aacute;vì s Dependency Injection pø&iacute;stupem
	a AOP je tedy z&aacute;kladn&iacute;m stavebn&iacute;m kamenem
	cel&eacute;ho popisovan&eacute;ho frameworku.<DT>
	Bal&iacute;ky <B>Spring Web</B> a <B>Web MVC</B> spoleènì zobecòuj&iacute;
	webov&eacute; aplikaèn&iacute; rozhran&iacute;. V Javì existuje
	obrovsk&eacute; mno¾stv&iacute; webov&yacute;ch technologi&iacute;,
	tedy postupù, jak&yacute;m zpùsobem obhospodaøit webov&yacute;
	(napø. http) po¾adavek, poslat ho pø&iacute;slu&scaron;n&yacute;m
	komponent&aacute;m (tzv akc&iacute;m), vykonat nezbytnou èinnost
	(nad nìjak&yacute;mi business) a korektnì vr&aacute;tit klientovi
	v&yacute;sledek. Jeliko¾ vìt&scaron;ina webov&yacute;ch protokolù je
	bezstavov&aacute;, k tomuto se je&scaron;tì pøid&aacute;v&aacute;
	nutnost uchov&aacute;vat sezen&iacute;. D&iacute;ky tomuto bal&iacute;ku
	mù¾ete sjednotit pr&aacute;ci s webov&yacute;mi frameworky a nic v&aacute;m
	nemù¾e br&aacute;nit snadno nahradit technologii Servlet technologi&iacute;
	Struts nebo WebWork, technologii JSP technologi&iacute; JSF a
	podobnì.</DL>
<H2>
Spring jako komponentov&aacute; technologie</H2>
<DL>
	<DT>V n&aacute;sleduj&iacute;c&iacute; è&aacute;sti si pøibl&iacute;¾&iacute;me
	samotn&eacute; komponenty ve Springu. Komponenta je ve Springu
	obyèejn&aacute; javovsk&aacute; tø&iacute;da (POJO &ndash; Plain Old
	Java Object &ndash; star&yacute; dobr&yacute; obyèejn&yacute;
	objekt). D&iacute;ky dostateèn&eacute; podpoøe platformy Java
	(reflexe, RMI...) nen&iacute; nutno zav&aacute;dìt ¾&aacute;dn&aacute;
	specifika a jeliko¾ je cel&yacute; framework urèen pr&aacute;vì pro
	tuto platformu Java, nen&iacute; divu, ¾e se komponenty naz&yacute;vaj&iacute;
	n&aacute;zvem Beans (resp. dlouze: Java Beans). Jako Bean se toti¾
	oznaèuje libovoln&yacute; java objekt, kter&yacute; m&aacute; jednu
	nebo v&iacute;ce vlastnost&iacute;.<DT>
	Jak jsem se ji¾ zm&iacute;nil, Spring vyu¾&iacute;v&aacute;
	vp&iacute;chnut&iacute; z&aacute;vislost&iacute; a &uacute;lohu
	assembleru pøeb&iacute;r&aacute; j&aacute;dro Springu. Z&aacute;vislosti
	komponent se naè&iacute;taj&iacute; z XML souboru, zde je kr&aacute;tk&yacute;
	pø&iacute;klad:</DL>
<PRE LANG=""><FONT SIZE=2><B>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;</B></FONT>
  <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;database&quot;&gt;&lt;ref bean=&quot;db&quot;/&gt;&lt;/property&gt;</B></SPAN></FONT>
  <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;numConnections&quot;&gt;&lt;value&gt;32&lt;/value&gt;&lt;/property&gt;</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>&lt;/bean&gt;</B></SPAN></FONT>

<FONT SIZE=2><SPAN LANG=""><B>&lt;bean id=&quot;db&quot; class=&quot;examples.DatabaseBean&quot;/&gt;</B></SPAN></FONT></PRE>
<DL>
	<DT>
	K v&yacute;pisu netøeba ¾&aacute;dn&yacute; koment&aacute;ø a pomalu
	si dovol&iacute;m odkazovat na dokumentaci, kter&aacute; je ve
	Springu pomìrnì rozs&aacute;hl&aacute;, &uacute;pln&aacute; a
	pøehledn&aacute; (co¾ u mnoha open-source projektù bohu¾el neb&yacute;v&aacute;
	zvykem). Spring nab&iacute;z&iacute; tak&eacute; vp&iacute;chnut&iacute;
	pomoc&iacute; konstruktoru, staè&iacute; nahradit znaèku <I>property</I>
	znaèkou <I>constructor-arg</I>.<DT>
	Definièn&iacute; soubory XML maj&iacute; promy&scaron;lenou
	strukturu a je zde my&scaron;leno na sebemen&scaron;&iacute; detail
	&ndash; m&aacute;te mo¾nost pøed&aacute;vat ve&scaron;ker&eacute;
	mo¾n&eacute; hodnoty (è&iacute;sla, øetìzce), odkazy na jin&eacute;
	objekty èi null hodnotu. Samozøejm&aacute; je podpora java kolekc&iacute;
	(List, Set, Map, Properties), singletonù, abstraktn&iacute;ch tø&iacute;d
	a abstraktn&iacute;ch tov&aacute;ren. V definièn&iacute;ch souborech
	se daj&iacute; pou¾&iacute;vat i pokroèil&eacute; techniky jako jsou
	runtime delegace a v&yacute;mìna metody, bli¾&scaron;&iacute;
	informace jsou v dokumentaci.<DT>
	Spring je schopn&yacute; z&aacute;vislosti vytv&aacute;øet
	automaticky (tzv. autowiring mode). Nab&iacute;z&iacute; hned
	nìkolik typù autowiringu, d&iacute;ky kter&yacute;m je dokonce mo¾no
	aplikaci nastavit tak, ¾e nen&iacute; nutn&eacute; pøi vytv&aacute;øen&iacute;
	dal&scaron;&iacute;ch a dal&scaron;&iacute;ch komponent (a nutn&yacute;ch
	z&aacute;vislost&iacute;) znovu zasahovat do XML konfigurace (co¾ je
	nìkdy znaènì zdr¾uj&iacute;c&iacute;). Nutno podotknout, ¾e pøi
	rozs&aacute;hlej&scaron;&iacute;ch aplikac&iacute;ch pak nemus&iacute;
	b&yacute;t zøejm&eacute;, kter&aacute; komponenta obsahuje jinou.
	Autowiring m&oacute;d lze nastavovat pro ka¾d&yacute; bean zvl&aacute;&scaron;»,
	co¾ je velk&aacute; v&yacute;hoda.<DT>
	Komponenty v Beanu nemusej&iacute; povinnì implementovat ¾&aacute;dn&eacute;
	metody (init, destroy a podobnì). Teprve a¾ kdy¾ je nutn&eacute;
	explicitnì kontrolovat ¾ivotn&iacute; cyklus komponenty, je mo¾no
	implementovat definovan&aacute; rozhran&iacute; (InitializingBean,
	DisposableBean). Podobn&eacute; je to s komponentou BeanFactory, co¾
	je objekt zaji&scaron;»uj&iacute;c&iacute; èten&iacute; vlastn&iacute;
	konfiguraci &ndash; a¾ kdy¾ ji komponenta potøebuje, implementuje
	urèit&eacute; rozhran&iacute;. Tady je z&aacute;sadn&iacute; rozd&iacute;l
	oproti J2EE.<DT>
	V&scaron;echny aspekty j&aacute;dra lze dobøe roz&scaron;iøovat,
	tak¾e pokud nebudete m&iacute;t mo¾nost pomoc&iacute; XML souboru
	nastavit nìjak&yacute; objekt, kter&yacute; nebude primitivn&iacute;m
	typem nebo z&aacute;kladn&iacute; tø&iacute;dou Javy, mù¾ete si
	snadno vytvoøit takzvan&yacute; PropertyEditor.</DL>
<H2>
Spring Context</H2>
<DL>
	<DT>Souè&aacute;st&iacute; frameworku je kontext aplikace
	usnadòuj&iacute;c&iacute; nìkter&eacute; operace, kter&eacute; mus&iacute;
	program&aacute;tor èasto øe&scaron;it. Prvn&iacute;m je API pro
	jednotn&yacute; pø&iacute;stup k prostøedkùm (soubor na disku, v
	kontextu webov&eacute; aplikace, na s&iacute;ti nebo z CLASSPATH).
	Podpora snadn&eacute; lokalizace je tak&eacute; souè&aacute;st&iacute;
	tohoto bal&iacute;ku.<DT>
	Podpora validace vstupù jde ruku v ruce s nav&aacute;z&aacute;n&iacute;m
	vstupn&iacute;ch hodnot na dom&eacute;nov&eacute; objekty. K tìmto
	&uacute;èelùm se pou¾&iacute;vaj&iacute; rozhran&iacute; DataBinder
	a Validator. K tìmto &uacute;èelùm se vyu¾&iacute;v&aacute;
	standardn&iacute;ho API definovan&eacute;ho pø&iacute;mo firmou Sun
	pro JavaBeans, pomoc&iacute; kter&eacute;ho si Spring &bdquo;hl&iacute;d&aacute;&ldquo;
	zmìny v datov&yacute;ch objektech a tyto hodnoty validuje pomoc&iacute;
	Validator API.<DT>
	Validace prob&iacute;h&aacute; tak, ¾e v XML souboru staè&iacute; u
	vlastnosti zadat dan&yacute; valid&aacute;tor a ten implementovat. V
	nìm  mù¾ete pou¾&iacute;t pøeddefinovan&eacute; valid&aacute;tory
	pro jednotliv&eacute; vlastnosti objektu (JavaBeanu) . Pokud n&aacute;m
	nebude vyhovovat nìkter&yacute; z vestavìn&yacute;ch (napø&iacute;klad
	cel&eacute; è&iacute;slo, øetìzec o minim&aacute;ln&iacute; d&eacute;lce,
	nebo regul&aacute;rn&iacute; v&yacute;raz), mù¾eme definovat
	vlastn&iacute;:<DT>
	<BR>
</DL>
<PRE LANG=""><FONT SIZE=2><B>public class PersonValidator implements Validator {</B></FONT>
        
        <FONT SIZE=2><SPAN LANG=""><B>public boolean supports(Class clzz) {</B></SPAN></FONT>
                <FONT SIZE=2><SPAN LANG=""><B>return Person.class.equals(clzz);</B></SPAN></FONT>
        <FONT SIZE=2><SPAN LANG=""><B>}</B></SPAN></FONT>
        
        <FONT SIZE=2><SPAN LANG=""><B>public void validate(Object obj, Errors e) {</B></SPAN></FONT>
                <FONT SIZE=2><SPAN LANG=""><B>ValidationUtils.rejectIfEmpty(e, &quot;name&quot;, &quot;name.empty&quot;);</B></SPAN></FONT>
                <FONT SIZE=2><SPAN LANG=""><B>Person p = (Person)obj;</B></SPAN></FONT>
                <FONT SIZE=2><SPAN LANG=""><B>if (p.getAge() &lt; 0) {</B></SPAN></FONT>
                        <FONT SIZE=2><SPAN LANG=""><B>e.rejectValue(&quot;age&quot;, &quot;negativevalue&quot;);</B></SPAN></FONT>
                <FONT SIZE=2><SPAN LANG=""><B>} else if (p.getAge() &gt; 110) {</B></SPAN></FONT>
                        <FONT SIZE=2><SPAN LANG=""><B>e.rejectValue(&quot;age&quot;, &quot;tooold&quot;);</B></SPAN></FONT>
                <FONT SIZE=2><SPAN LANG=""><B>}</B></SPAN></FONT>
        <FONT SIZE=2><SPAN LANG=""><B>}</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>}</B></SPAN></FONT></PRE><H2>
Aspektovì orientovan&eacute; programov&aacute;n&iacute;</H2>
<DL>
	<DT>Aèkoliv AOP tvoø&iacute; ned&iacute;lnou souè&aacute;st Spring
	Frameworku a jeho autor navrhoval v&scaron;echna rozhran&iacute;
	tak, aby byly &bdquo;AOP-kompatibiln&iacute;&ldquo;, tak se nebudu
	t&eacute;to è&aacute;sti pø&iacute;li&scaron; vìnovat. Dùvodem je
	zejm&eacute;na fakt, ¾e bych kop&iacute;roval kolegy, kteø&iacute;
	maj&iacute; pøedn&aacute;&scaron;ky na toto t&eacute;ma a jistì
	pop&iacute;&scaron;&iacute; celou problematiku podrobnìji.<DT>
	Spring nevyu¾&iacute;v&aacute; asi nejpou¾&iacute;vanìj&scaron;&iacute;
	knihovnu AspectJ, ale rozhran&iacute; AOP Alliance, kter&eacute; je
	takt&eacute;¾ poskytov&aacute;no jako open-source. Spring se toti¾
	nesna¾&iacute; pokr&yacute;t v&scaron;echny mo¾nosti, kter&eacute;
	AOP nab&iacute;z&iacute;, ale zamìøuje se zejm&eacute;na na tu
	oblast, kter&aacute; je dobøe vyu¾iteln&aacute; v postupech, kter&eacute;
	Spring vyu¾&iacute;v&aacute;. Ov&scaron;em v pl&aacute;nech pro
	verzi 1.1 je kompletn&iacute; podpora pro AspectJ.</DL>
<H2>
Transakèn&iacute; zpracov&aacute;n&iacute;</H2>
<DL>
	<DT>V Javì existuje velk&eacute; mno¾stv&iacute; rùzn&yacute;ch
	rozhran&iacute; a standardizovan&yacute;ch API pro transakèn&iacute;
	zpracov&aacute;n&iacute; (a» u¾ pouze o datab&aacute;zov&eacute;
	jako napø&iacute;klad JDBC, Hibernate èi iBatis, nebo v&iacute;ce
	generick&eacute;, jako napø&iacute;klad JTA). Spring opìt pln&iacute;
	&uacute;lohu jak&eacute;hosi &bdquo;lepidla&ldquo; a poskytuje
	obecn&eacute; rozhran&iacute;, aby bylo mo¾n&eacute; pou¾&iacute;t
	libovoln&eacute; API a pozdìji jej vymìnit (napø&iacute;klad JDBC a
	v pø&iacute;padì nutnosti vymìnit za JTA).<DT>
	V EJB je nutn&eacute; striktnì rozli&scaron;ovat glob&aacute;ln&iacute;
	a lok&aacute;ln&iacute; transakce (transakce napø&iacute;klad na
	&uacute;rovni datab&aacute;zov&eacute;ho spojen&iacute;). Tak&eacute;
	se zde pou¾&iacute;v&aacute; rozhran&iacute; JNDI a transakce jsou
	obvykle z&aacute;visl&eacute; na aplikaèn&iacute;m serveru (vy¾aduj&iacute;
	jeho nasazen&iacute; &ndash; CMT &ndash; Container Management
	Transacitons). V pø&iacute;padì Springu pou¾&iacute;v&aacute;te v¾dy
	jednotn&eacute; rozhran&iacute; a nevy¾aduje pou¾it&iacute;
	aplikaèn&iacute;ho serveru, pokud to nen&iacute; nutn&eacute;.</DL>
<PRE LANG=""><FONT SIZE=2><B>public interface PlatformTransactionManager {</B></FONT>

    <FONT SIZE=2><SPAN LANG=""><B>TransactionStatus getTransaction(TransactionDefinition definition)</B></SPAN></FONT>
        <FONT SIZE=2><SPAN LANG=""><B>throws TransactionException;</B></SPAN></FONT>

    <FONT SIZE=2><SPAN LANG=""><B>void commit(TransactionStatus status) throws TransactionException;</B></SPAN></FONT>

    <FONT SIZE=2><SPAN LANG=""><B>void rollback(TransactionStatus status) throws TransactionException;</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>}</B></SPAN></FONT></PRE>
<DL>
	<DT>
	Na v&yacute;pisu vid&iacute;me API (jedn&aacute; se opìt o rozhran&iacute;
	a pøipom&iacute;n&aacute;m, ¾e Spring je vlastnì hlavnì o
	rozhran&iacute;ch, abstraktn&iacute;ch pomocn&yacute;ch tø&iacute;d&aacute;ch
	a pøehledn&eacute; dokumentaci). Metoda getTransaction pø&iacute;mo
	vyhled&aacute; vhodnou transakci na z&aacute;kladì jej&iacute;
	definice, kde specifikujeme izolov&aacute;n&iacute;, timeout a
	podobnì.<DT>
	N&aacute;sleduj&iacute;c&iacute; pø&iacute;klad ukazuje pou¾it&iacute;
	Hibernate Transaction Manageru. Nejprve si zadefinujeme datov&yacute;
	zdroj (spojen&iacute; na SQL datab&aacute;zi).</DL>
<PRE LANG=""><FONT SIZE=2><B>&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</B></FONT>
  <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driverClassName}&quot;/&gt;</B></SPAN></FONT>
  <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;</B></SPAN></FONT>
  <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;</B></SPAN></FONT>
  <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>&lt;/bean&gt;</B></SPAN></FONT></PRE>
<DL>
	<DT>
	D&aacute;le je tøeba m&iacute;t nastaven&yacute; Hibernate O/R
	mapper, o kter&eacute;m budeme je&scaron;tì mluvit.</DL>
<PRE LANG=""><FONT SIZE=2><B>&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate.LocalSessionFactoryBean&quot;&gt;</B></FONT>
  <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</B></SPAN></FONT>
  <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;mappingResources&quot;&gt;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>&lt;list&gt;</B></SPAN></FONT>
      <FONT SIZE=2><SPAN LANG=""><B>&lt;value&gt;samples/petclinic/hibernate/petclinic.hbm.xml&lt;/value&gt;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>&lt;/list&gt;</B></SPAN></FONT>
  <FONT SIZE=2><SPAN LANG=""><B>&lt;/property&gt;</B></SPAN></FONT>
  <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;hibernateProperties&quot;&gt;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>&lt;props&gt;</B></SPAN></FONT>
      <FONT SIZE=2><SPAN LANG=""><B>&lt;prop key=&quot;hibernate.dialect&quot;&gt;${hibernate.dialect}&lt;/prop&gt;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>&lt;/props&gt;</B></SPAN></FONT>
  <FONT SIZE=2><SPAN LANG=""><B>&lt;/property&gt;</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>&lt;/bean&gt;</B></SPAN></FONT></PRE>
<DL>
	<DT>
	Vytvoøen&iacute; komponenty <I>txManager</I>, kter&aacute; bude
	poskytovat transakèn&iacute; slu¾by, je pak velmi jednoduch&eacute;.</DL>
<PRE LANG=""><FONT SIZE=2><B>&lt;bean id=&quot;txManager&quot; class=&quot;org.spring.orm.hibernate.HibernateTransactionManager&quot;&gt;</B></FONT>
  <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>&lt;/bean&gt;</B></SPAN></FONT></PRE>
<DL>
	<DT>
	To je v&scaron;e. V&scaron;imnìte si, ¾e v&scaron;e jsou komponenty
	(z pohledu Springu), co¾ v EJB tak &uacute;plnì neplat&iacute; (tam
	se pracuje pø&iacute;mo s rozhran&iacute;mi JNDI, JTA a podobnì).
	Stejnì jako v EJB v&scaron;ak Spring rozli&scaron;uje transakce na
	&uacute;rovni aplikace (programmatic transaction support), kde je
	pø&iacute;stup podobn&yacute; rozhran&iacute; JTA (Java Transaction
	API) s t&iacute;m rozd&iacute;lem, ¾e mù¾ete implementaci nahradit
	jinou knihovnou.<DT>
	V pø&iacute;padì, ¾e budete potøebovat vyu¾&iacute;t slu¾eb
	nìkter&eacute;ho z aplikaèn&iacute;ch serverù, pak Spring poskytuje
	implementace konektorù k serverùm BEA WebLogic a IBM Websphere.</DL>
<H2>
Znaèkov&aacute;n&iacute; v koment&aacute;ø&iacute;ch</H2>
<DL>
	<DT>Jazyk Java verze 1.5 zavedl popisov&aacute;n&iacute; zdrojov&yacute;ch
	k&oacute;dù pomoc&iacute; metadat. Jeliko¾ Spring je vyzr&aacute;l&yacute;
	produkt (vznikl v dobì, kdy byla produkèn&iacute; verze 1.4) a
	jeliko¾ autor Springu nechce nutit program&aacute;tory, aby
	st&aacute;vaj&iacute;c&iacute; projekty pøev&aacute;dìli do nov&eacute;
	verze jazyka Java (kter&eacute; v nìkter&yacute;ch pø&iacute;padech
	<B>nen&iacute; </B>zpìtnì kompatibiln&iacute; a vy¾aduje z&aacute;sahy
	do zdrojov&yacute;ch k&oacute;dù), vyu¾&iacute;v&aacute; Spring
	slu¾eb projektù XDoclet a commons-attributtes, co¾ jsou open-source
	implementace Source-level Metadat.<DT>
	Spring v&scaron;e zobecòuje do t&eacute; &uacute;rovnì, ¾e je mo¾no
	pøistupovat k tìmto implementac&iacute;m zcela nez&aacute;visle,
	nav&iacute;c dod&aacute;v&aacute; podporu i pro Javu 1.5. Pokud se
	tedy jedn&aacute; o star&scaron;&iacute; projekt, mù¾e vyu¾&iacute;t
	slu¾eb XDocletu, v pø&iacute;padì nov&eacute;ho pak napø&iacute;klad
	nativn&iacute; podpory v Javì 1.5. Napø&iacute;klad platforma .NET
	m&aacute; svoji implementaci metainformac&iacute; ji¾ od sv&yacute;ch
	ran&yacute;ch verz&iacute;. 
	<DT>A jak&aacute; je hlavn&iacute; v&yacute;hoda source-level
	metadat? Program&aacute;tor z&iacute;sk&aacute;v&aacute; mo¾nost
	pøid&aacute;vat ke tø&iacute;d&aacute;m, metod&aacute;m, vlastnostem
	a atributùm zvl&aacute;&scaron;tn&iacute; informace (takø&iacute;kaj&iacute;c
	informace &bdquo;nav&iacute;c&ldquo; - metainformace). Typick&yacute;m
	pø&iacute;kladem mù¾e b&yacute;t oznaèen&iacute; urèit&eacute; tø&iacute;dy
	jako DAO objekt (datab&aacute;zov&yacute; dom&eacute;nov&yacute;
	objekt). Spring pak mù¾e vyhledat v&scaron;echny DAO objekty v
	aplikaci a prov&eacute;st napø&iacute;klad jejich pøevod, vytvoøit
	SQL strukturu a podobnì. Na uk&aacute;zce vid&iacute;me atribut
	PoolingAttribut, kter&yacute; oznaèuje danou tø&iacute;du pro
	znovupou¾it&iacute;.</DL>
<PRE LANG=""> <FONT SIZE=2><B>/** </B></FONT>
 <FONT SIZE=2><SPAN LANG=""><B>* @@org.spring.aop.framework.autoproxy.target.PoolingAttribute(10)</B></SPAN></FONT>
 <FONT SIZE=2><SPAN LANG=""><B>* @author Rod Johnson</B></SPAN></FONT>
 <FONT SIZE=2><SPAN LANG=""><B>*/</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>public class MyClass {</B></SPAN></FONT></PRE>
<DL>
	<DT>
	Zde je vidìt jedna z nev&yacute;hod implementace metadat v Javì 1.5
	&ndash; tam toti¾ jsou v&scaron;echna metadata ulo¾en&aacute; ve
	zkompilovan&eacute;m class souboru a nen&iacute; mo¾n&eacute; je
	dynamicky mìnit. Pokud bychom napø&iacute;klad chtìli bez
	rekompilace zmìnit maxim&aacute;ln&iacute; poèet objektù v poolu (na
	pø&iacute;kladì 10), museli bychom pou¾&iacute;t XDoclet. Tato
	vlastnost by se mìla objevit v Javì 6.0.</DL>
<H2>
DAO a objektovì-relaèn&iacute; mapping</H2>
<DL>
	<DT>Najde se jen m&aacute;lo obchodn&iacute;ch aplikac&iacute; bez
	datab&aacute;z&iacute;, proto Spring nab&iacute;z&iacute; nìkolik
	metod pro pø&iacute;stup k nim. Pou¾it&aacute; technika DAO je
	nez&aacute;visl&aacute; na tom, kter&yacute; pø&iacute;stup si
	vyberete. Spring se nesna¾&iacute; jako J2EE vytvoøit vlastn&iacute;
	vrstvu pro ukl&aacute;d&aacute;n&iacute; objektov&yacute;ch dat, ale
	pou¾&iacute;v&aacute; k tomu &scaron;pièkov&eacute; open-source
	projekty, kter&eacute; jsou ovìøen&eacute; trhem i èasem.<DT>
	Ve Springu mù¾ete pou¾&iacute;vat pø&iacute;mo rozhran&iacute; JDBC,
	pøièem¾ se Spring sna¾&iacute; zastøe&scaron;it a sjednotit nìkter&eacute;
	vìci. Jednak je to vlastn&iacute; pø&iacute;stup k datab&aacute;zi
	(otevøen&iacute; spojen&iacute;) a d&aacute;le obsluha v&yacute;jimek,
	kter&aacute; je v souèasn&eacute; verzi JDBC nedostateènì
	standardizovan&aacute; a li&scaron;&iacute; se od dodavatele
	datab&aacute;ze. Spring tak&eacute; definuje API zastøe&scaron;uj&iacute;c&iacute;
	SQL dotazy pro zjednodu&scaron;en&iacute; vytv&aacute;øen&iacute;
	mapuj&iacute;c&iacute;ch tø&iacute;d, co¾ jsou tø&iacute;dy
	pøev&aacute;dìj&iacute;c&iacute; v&yacute;sledky vol&aacute;n&iacute;
	JDBC vrstvy na datab&aacute;zov&eacute; objekty.<DT>
	Hlavn&iacute; s&iacute;la Springu je bezesporu ve v&yacute;born&eacute;
	integraci s knihovnami Hibernate, Oracle TopLink, Apache OJB nebo
	iBatis. Poskytuj&iacute; spojen&iacute; mezi dom&eacute;nov&yacute;mi
	objekty a relaèn&iacute; datab&aacute;z&iacute;. Princip spoè&iacute;v&aacute;
	v tom, ¾e JavaBeans komponenty a jejich vlastnosti jsou namapov&aacute;ny
	(pomoc&iacute; konfiguraèn&iacute;ch souborù) do datab&aacute;zov&yacute;ch
	tabulek. Knihovna samotn&aacute; se postar&aacute; o jejich spr&aacute;vn&eacute;
	vyzvednut&iacute;, o&scaron;etøuje kolekce (spojov&aacute;n&iacute;
	dotazù), v&yacute;jimky a cachov&aacute;n&iacute;.<DT>
	Zde je uk&aacute;zka pou¾it&iacute; Hibernate, co¾ je defacto
	standard mezi O/R mapovac&iacute;mi syst&eacute;my. Firma Sun
	Microsystems sice vytvoøila standardizovanou API JDO, ale ta pøi&scaron;la
	jednak dost pozdì (projekt Hibernate je jeden z nejstar&scaron;&iacute;ch)
	a hlavnì verze 1.0 nedosahovala takov&yacute;ch kvalit a mo¾nost&iacute;,
	jako Hibernate.<DT>
	Nejdø&iacute;ve je nutno nadefinovat JDBC spojen&iacute; (Hibernate
	pracuje nad JDBC), pak velmi dùle¾itou komponentu &ndash;
	SessionFactory. Je to vlastnì takov&aacute; &bdquo;instance&ldquo;
	knihovny Hibernate jako takov&eacute;. V n&iacute; se prov&aacute;d&iacute;
	hlavn&iacute; konfigurace (vèetnì nastaven&iacute; mapovac&iacute;ch
	XML souborù, kter&eacute; lze pomoc&iacute; rùzn&yacute;ch n&aacute;strojù
	generovat automaticky).</DL>
<PRE LANG=""><FONT SIZE=2><B>&lt;beans&gt;</B></FONT>

  <FONT SIZE=2><SPAN LANG=""><B>&lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;driverClassName&quot; value=&quot;org.hsqldb.jdbcDriver&quot;/&gt;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;url&quot; value=&quot;jdbc:hsqldb:hsql://localhost:9001&quot;/&gt;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;username&quot; value=&quot;sa&quot;/&gt;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;password&quot; value=&quot;&quot;/&gt;</B></SPAN></FONT>
  <FONT SIZE=2><SPAN LANG=""><B>&lt;/bean&gt;</B></SPAN></FONT>

  <FONT SIZE=2><SPAN LANG=""><B>&lt;bean id=&quot;mySessionFactory&quot; class=&quot;org.springframework.orm.hibernate.LocalSessionFactoryBean&quot;&gt;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;dataSource&quot; ref=&quot;myDataSource/&gt;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;mappingResources&quot;&gt;</B></SPAN></FONT>
      <FONT SIZE=2><SPAN LANG=""><B>&lt;list&gt;</B></SPAN></FONT>
        <FONT SIZE=2><SPAN LANG=""><B>&lt;value&gt;product.hbm.xml&lt;/value&gt;</B></SPAN></FONT>
      <FONT SIZE=2><SPAN LANG=""><B>&lt;/list&gt;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>&lt;/property&gt;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>&lt;property name=&quot;hibernateProperties&quot;&gt;</B></SPAN></FONT>
      <FONT SIZE=2><SPAN LANG=""><B>&lt;props&gt;</B></SPAN></FONT>
        <FONT SIZE=2><SPAN LANG=""><B>&lt;prop key=&quot;hibernate.dialect&quot;&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/prop&gt;</B></SPAN></FONT>
      <FONT SIZE=2><SPAN LANG=""><B>&lt;/props&gt;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>&lt;/property&gt;</B></SPAN></FONT>
  <FONT SIZE=2><SPAN LANG=""><B>&lt;/bean&gt;</B></SPAN></FONT>

   <FONT SIZE=2><SPAN LANG=""><B>...</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>&lt;/beans&gt;</B></SPAN></FONT></PRE>
<DL>
	<DT>
	Vlastn&iacute; dotaz v DAO je pak n&aacute;sleduj&iacute;c&iacute;:</DL>
<PRE LANG=""><FONT SIZE=2><B>public class ProductDaoImpl implements ProductDao {</B></FONT>

    <FONT SIZE=2><SPAN LANG=""><B>private SessionFactory sessionFactory;</B></SPAN></FONT>

    <FONT SIZE=2><SPAN LANG=""><B>public void setSessionFactory(SessionFactory sessionFactory) {</B></SPAN></FONT>
        <FONT SIZE=2><SPAN LANG=""><B>this.sessionFactory = sessionFactory;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>}</B></SPAN></FONT>

    <FONT SIZE=2><SPAN LANG=""><B>public Collection loadProductsByCategory(String category) {</B></SPAN></FONT>
        <FONT SIZE=2><SPAN LANG=""><B>return this.sessionFactory.getCurrentSession()</B></SPAN></FONT>
                <FONT SIZE=2><SPAN LANG=""><B>.createQuery(&quot;from test.Product product where product.category=?&quot;)</B></SPAN></FONT>
                <FONT SIZE=2><SPAN LANG=""><B>.setParameter(0, category)</B></SPAN></FONT>
                <FONT SIZE=2><SPAN LANG=""><B>.list();</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>}</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>}</B></SPAN></FONT></PRE>
<DL>
	<DT>
	Transakce mù¾eme na v nejvy&scaron;&scaron;&iacute; &uacute;rovni
	øe&scaron;it tak&eacute; zaj&iacute;mav&yacute;m zpùsobem &ndash;
	anonymn&iacute;mi tø&iacute;dami:</DL>
<PRE LANG=""><FONT SIZE=2><B>public class ProductServiceImpl implements ProductService {</B></FONT>

    <FONT SIZE=2><SPAN LANG=""><B>private PlatformTransactionManager transactionManager;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>private ProductDao productDao;</B></SPAN></FONT>

    <FONT SIZE=2><SPAN LANG=""><B>public void setTransactionManager(PlatformTransactionManager transactionManager) {</B></SPAN></FONT>
        <FONT SIZE=2><SPAN LANG=""><B>this.transactionManager = transactionManager;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>}</B></SPAN></FONT>

    <FONT SIZE=2><SPAN LANG=""><B>public void setProductDao(ProductDao productDao) {</B></SPAN></FONT>
        <FONT SIZE=2><SPAN LANG=""><B>this.productDao = productDao;</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>}</B></SPAN></FONT>

    <FONT SIZE=2><SPAN LANG=""><B>public void increasePriceOfAllProductsInCategory(final String category) {</B></SPAN></FONT>
        <FONT SIZE=2><SPAN LANG=""><B>TransactionTemplate transactionTemplate = new TransactionTemplate(this.transactionManager);</B></SPAN></FONT>
        <FONT SIZE=2><SPAN LANG=""><B>transactionTemplate.execute(</B></SPAN></FONT>
            <FONT SIZE=2><SPAN LANG=""><B>new TransactionCallbackWithoutResult() {</B></SPAN></FONT>
                <FONT SIZE=2><SPAN LANG=""><B>public void doInTransactionWithoutResult(TransactionStatus status) {</B></SPAN></FONT>
                    <FONT SIZE=2><SPAN LANG=""><B>List productsToChange = productDAO.loadProductsByCategory(category);</B></SPAN></FONT>
                    <FONT SIZE=2><SPAN LANG=""><B>...</B></SPAN></FONT>
                <FONT SIZE=2><SPAN LANG=""><B>}</B></SPAN></FONT>
            <FONT SIZE=2><SPAN LANG=""><B>}</B></SPAN></FONT>
        <FONT SIZE=2><SPAN LANG=""><B>);</B></SPAN></FONT>
    <FONT SIZE=2><SPAN LANG=""><B>}</B></SPAN></FONT>
<FONT SIZE=2><SPAN LANG=""><B>}</B></SPAN></FONT></PRE>
<DL>
	<DT>
	Na Hibernate (i jin&eacute; mapovaèn&iacute; rozhran&iacute;) mù¾e
	program&aacute;tor pøistupovat i na ni¾&scaron;&iacute; &uacute;rovni
	(tj. ruènì zah&aacute;jit transakci, vr&aacute;tit seznam objektù z
	dotazu, o&scaron;etøit v&yacute;jimky, commitnout transakci).<DT>
	Aèkoli O/R mapovac&iacute; rohzran&iacute; tvoø&iacute; z&aacute;klad
	obchodn&iacute;ch aplikac&iacute;, nebudu se tomuto t&eacute;matu
	nad&aacute;le vìnovat a pøejdu k z&aacute;vìreènì a asi
	nejzaj&iacute;mavìj&scaron;&iacute; f&aacute;zi.</DL>
<H2>
Webov&aacute; è&aacute;st</H2>
<DL>
	<DT>Webov&aacute; è&aacute;st zastøe&scaron;uje kompletn&iacute; MVC
	pø&iacute;stup pro tvorbu webov&yacute;ch aplikac&iacute;. Aèkoli
	program&aacute;torovi nic nebr&aacute;n&iacute; pou¾&iacute;t
	jin&yacute;/vlastn&iacute; aplikaèn&iacute; r&aacute;mec (Struts,
	Tapestry, Velocity/Freemaker, XLST, Tiles, JasperReports), pou¾it&iacute;
	implementace ve Springu m&aacute; øadu v&yacute;hod:</DL>
<UL>
	<LI>
	<I>èist&aacute; separace v&scaron;ech rol&iacute;</I> &ndash; v
	mnoha MVC r&aacute;mc&iacute;ch se sluèuj&iacute; pojmy jako form a
	model, validator a model a podobnì,<LI>
	<I>jednoduch&aacute; konfigurace</I> &ndash; Spring pou¾&iacute;v&aacute;
	samozøejmì na v&scaron;echno JavaBeans komponenty a s t&iacute;m je
	spojena øada dal&scaron;&iacute;ch v&yacute;hod,<LI>
	<I>znovupou¾it&iacute; business tø&iacute;d</I> &ndash; nemus&iacute;te
	vytv&aacute;øet dal&scaron;&iacute; objekty typu Form, ve Springu
	pou¾ijete pø&iacute;mo business komponenty,<LI>
	<I>naz&aacute;visl&eacute; mapov&aacute;n&iacute;</I> &ndash;
	handlery a pohledy jsou nez&aacute;visl&eacute; a mù¾ete pou¾&iacute;t
	v&iacute;ce pø&iacute;stupù.</UL>
<DL>
	<DT>Spring obsahuje pø&iacute;mou podporu JSP a tak&eacute; jakousi
	ad-hoc podporu (zat&iacute;m) pro novou technologii JSF.<DT>
	V&scaron;echny kl&iacute;èov&eacute; komponenty (Controller, Model,
	View) jsou souè&aacute;st&iacute; Springu a ten nav&iacute;c
	obsahuje mnoho pøipraven&yacute;ch implementac&iacute;. Typick&aacute;
	aplikace pomoc&iacute; Spring MVC je nakonfigurovan&aacute; tak, aby
	na stranì J2EE kontejneru pøed&aacute;vala v&scaron;echny dotazy na
	jeden jedin&yacute; servlet. Tento servlet pak naè&iacute;t&aacute;
	vlastn&iacute; konfiguraci a mapov&aacute;n&iacute; z XML souborù.
	V&scaron;echno jsou znovupou¾iteln&eacute; komponenty a velkou
	v&yacute;hodou je velk&aacute; prov&aacute;zanost s ji¾ vytvoøen&yacute;mi
	business objekty ve Springu.</DL>
<H2>
Dal&scaron;&iacute; technologie</H2>
<DL>
	<DT>Vyèerpali jsme hlavn&iacute; technologie, kter&eacute; se
	pou¾&iacute;vaj&iacute; pøi budov&aacute;n&iacute; obchodn&iacute;ch
	aplikac&iacute;. Spring toho v&scaron;ak nab&iacute;z&iacute; v&iacute;ce.
	Dobrou podporu m&aacute; pro webov&eacute; slu¾by (RMI, JAX-RPC),
	tak&eacute; zm&iacute;nìn&aacute; mo¾nost vytv&aacute;øet EJB
	komponenty patø&iacute; do t&eacute;to è&aacute;sti. Technologie JMS
	je nav&iacute;c doplnìna o Spring email infrastructure. Posledn&iacute;m
	èl&aacute;nkem je JCA CCI (Java Connector Architecture &ndash;
	Common Client Interface), co¾ je technologie pro v&yacute;mìnu
	obchodn&iacute;ch informac&iacute; v r&aacute;mci EIS.</DL>
<H2>
Literatura a odkazy:</H2>
<DL>
	<DT>[1] Rod Jonhson: <B>Expert One-on-One J2EE Design and
	Development</B>, Wiley Publ. 2003<DT>
	[2] Martin Flower: <B>Inversion of Control Containers and the
	Dependency Injection pattern</B>,
	<I>http://www.martinfowler.com/articles/injection.html</I><DT>
	[3] Sun Microsystems, <B>Core J2EE Patterns</B>, Sun
	Press,<I><BR>http://java.sun.com/blueprints/corej2eepatterns/Patterns/ServiceLocator.html</I><DT>
	[4] Das Spring Framework als Teil eines Paradigmenwechsels?
	Vergleich der leichtgewichtigen Alternative zur traditionellen J2EE
	Entwicklung, diplomov&aacute;
	pr&aacute;ce.<I><BR>http://www.martinmaier.name/archives/5</I><DT>
	[5] Sum Microsystems, J2EE Portal, ofici&aacute;ln&iacute;
	dokumentace technologie J2EE,<BR><I>http://java.sun.com/j2ee/</I></DL>
</BODY>
</HTML>