---
layout: post
title: Anatomy of Ruby Exception
date: 2011-11-28
tags:
- ruby
- pattern
---

<h1>{{ page.title }}</h1>
<p>Today I was trying to find how to properly override Ruby standard Exception. To my surprise, I was not able to find any tutorial or even paragraph about it. No recommendations, no design patterns. Everything was the same:</p> <pre><code>class MyError &lt; StandardError; end<br /></code></pre> <p>As a Java guy, I tend to encapsulate lots of things into Exceptions. It's not a bad thing, actually it is a good thing. So I asked myself - what should I override, how, and why?</p> <p>Let's skip the general Ruby recommendation to override StandardError instead Exception. Different class, the very same interface. To my surprise again, both Exception and StandardError classes are defined in the Ruby C code.</p> <p>So I have rewritten the Ruby Exception into this Ruby code. Please note I made my life a little easier and some of the methods do not return the exact output as Ruby does (e.g. inspect), but we get very good overview with it. Please note this is Ruby 1.8, there is one small change in 1.9 in regard to method to_str, but it makes no difference for us.</p> <pre><code>class Exception<br />  def initialize(msg)<br />    @mesg = msg<br />    @bt = nil<br />  end<br /><br />  def to_s<br />    return self.class.name if @mesg.nil?<br />    @mesg<br />  end<br /><br />  alias :message :to_s<br />  alias :to_str :to_s<br /><br />  def set_backtrace(bt)<br />    @bt = bt<br />  end<br /><br />  def backtrace<br />    @bt<br />  end<br /><br />  def inspect<br />    "\#&lt;#{self.class.name}&gt;: #{to_s}"<br />  end<br /><br />  def exception(msg)<br />    return self if msg == message<br />    self.class.new(msg)<br />  end<br />end<br /></code></pre> <p>I think the code says it all. Now we can see what we actually need to redefine. Now, let's do a small example.</p> <pre><code>class MyError &lt; StandardError<br />  attr_accessor :info<br /><br />  def initialize(msg, my_additional_info = "")<br />    info = my_additional_info<br />    super(msg)<br />  end<br /><br />  def message<br />    "#{to_s}: #{info}"<br />  end<br />end<br /></code></pre> <p>As you can see from the Exception code, Ruby stores the message into instance variable called "mesg". Since this is native code, we are not able to access it. The only way to get it is to call to_s method. Please do not do this:</p> <pre><code>def to_s<br />  "#{message}: #{@info}"<br />end<br /></code></pre> <p>This will end up with stack overflow. Special thanks to Ivan Neƒças for helping me with this.</p> <p>I have to admit this interface is not the best feature of Ruby. I can imagine an accessor for the message itself. And with a different name than "mesg". But that is life.</p> <p>Nobody told us Ruby programming's gonna be easy. Take care.</p>